#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{listings}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=Java"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Nibiru Mobile 0.2 Reference
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename logo.png

\end_inset


\end_layout

\begin_layout Part
Introduction
\end_layout

\begin_layout Section
Framework objective
\end_layout

\begin_layout Standard
The framework objective is to facilitate building portable mobile applications.
 The following goals are established in order to meet such objective:
\end_layout

\begin_layout Itemize
Portable mobile development, allowing reusing most of the components.
\end_layout

\begin_layout Itemize
Support for both, native and HTML5 platforms.
\end_layout

\begin_layout Itemize
Unified API for commons components, with different implementations.
\end_layout

\begin_layout Itemize
Resuable components for common funcionality, built on top of unified API.
\end_layout

\begin_layout Itemize
Common structure and patterns for developing apps.
\end_layout

\begin_layout Section
Architecture
\end_layout

\begin_layout Standard
This section explains architectural decisions.
\end_layout

\begin_layout Subsection
High-level diagram
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename architecture.png
	scale 50

\end_inset


\end_layout

\begin_layout Subsection
Portable development
\end_layout

\begin_layout Standard
Nibiru Mobile provides a high degree of portability among differents platforms.
 It is not focused on developing 100% portable apps.
 Instead, it aims to make easy cross-platform development reusing most of
 the components.
\end_layout

\begin_layout Standard
Since 
\begin_inset CommandInset href
LatexCommand href
name "Java"
target "http://www.java.com/en/"

\end_inset

 is the base language (see next section), a common API is provided for both,
 
\begin_inset CommandInset href
LatexCommand href
name "Android"
target "http://www.android.com/"

\end_inset

 and 
\begin_inset CommandInset href
LatexCommand href
name "GWT"
target "https://developers.google.com/web-toolkit/"

\end_inset

 platforms.
 This way, you can develop both, HTML5 applications (using GWT) and native
 Android apps.
\end_layout

\begin_layout Subsection
Java platform
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Java"
target "http://www.java.com/en/"

\end_inset

was chosen because it is currently the most widespread platform within the
 enterprise applications, in addition to being easily portable to different
 environments and having many frameworks and libraries.
\end_layout

\begin_layout Standard
Most portable development platforms, such as 
\begin_inset CommandInset href
LatexCommand href
name "Apache Cordova"
target "http://incubator.apache.org/cordova/"

\end_inset

 (aka 
\begin_inset CommandInset href
LatexCommand href
name "PhoneGap"
target "http://phonegap.com/"

\end_inset

) or 
\begin_inset CommandInset href
LatexCommand href
name "Appcelerator"
target "http://www.appcelerator.com/"

\end_inset

 are based on JavaScript.
 We believe that this language is not suitable for enterprise development,
 since it lacks of many features such as packaging, strong typing, etc.
 Adding 
\begin_inset CommandInset href
LatexCommand href
name "GWT"
target "https://developers.google.com/web-toolkit/"

\end_inset

 over PhoneGap can solve these issues.
 However, Nibiru Mobile goes one step further, providing a common API not
 just for accessing hardware, but for many common components..
\end_layout

\begin_layout Subsection
IoC pattern
\end_layout

\begin_layout Standard
In order to decouple each component from the container and other components,
 the dependencies of each component are injected (
\begin_inset CommandInset href
LatexCommand href
name "IoC"
target "http://en.wikipedia.org/wiki/Inversion_of_Control"

\end_inset

 pattern).
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "JSR330"
target "http://www.jcp.org/en/jsr/detail?id=330"

\end_inset

, a Java standard for dependency injection, is used for configuring components
 in a framework-agnostic way.
 At each platform.
 specific frameworks such as 
\begin_inset CommandInset href
LatexCommand href
name "Guice"
target "http://code.google.com/p/google-guice/"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "RoboGuice"
target "http://code.google.com/p/roboguice/"

\end_inset

 or 
\begin_inset CommandInset href
LatexCommand href
name "GIN"
target "http://code.google.com/p/google-gin/"

\end_inset

 are used in order to implement this pattern.
\end_layout

\begin_layout Subsection
MVP pattern
\end_layout

\begin_layout Standard
The model used for the presentation layer is the MVP pattern, under its
 
\begin_inset CommandInset href
LatexCommand href
name "passive view"
target "http://martinfowler.com/eaaDev/PassiveScreen.html"

\end_inset

 variant.
 This allows the presenters to be decoupled from each other by an event
 bus and also to be decoupled from view implementation.
 Google also makes a good description of this 
\begin_inset CommandInset href
LatexCommand href
name "pattern"
target "http://code.google.com/intl/es-419/webtoolkit/articles/mvp-architecture.html"

\end_inset

.
\end_layout

\begin_layout Standard
Also, the concept of abstracting the view was taken a step further, creating
 abstractions for common components.
 Thus, the user can choose creating a generic view or creating a view using
 the particular advantages of a specific technology.
\end_layout

\begin_layout Section
Getting started
\end_layout

\begin_layout Subsection
Required software
\end_layout

\begin_layout Enumerate
Java (
\begin_inset CommandInset href
LatexCommand href
target "http://www.java.com/en/download/"

\end_inset

).
\end_layout

\begin_layout Enumerate
Eclipse (
\begin_inset CommandInset href
LatexCommand href
target "http://www.eclipse.org/"

\end_inset

).
\end_layout

\begin_layout Enumerate
Maven (
\begin_inset CommandInset href
LatexCommand href
target "http://maven.apache.org/"

\end_inset

).
\end_layout

\begin_layout Enumerate
A GIT client (
\begin_inset CommandInset href
LatexCommand href
target "http://git-scm.com/"

\end_inset

).
 We use 
\begin_inset CommandInset href
LatexCommand href
name "EGit"
target "http://eclipse.org/egit/"

\end_inset

.
\end_layout

\begin_layout Enumerate
Android Plugin (
\begin_inset CommandInset href
LatexCommand href
target "http://developer.android.com/tools/sdk/eclipse-adt.html"

\end_inset

)
\end_layout

\begin_layout Enumerate
GWT Plugin (
\begin_inset CommandInset href
LatexCommand href
target "https://developers.google.com/eclipse/"

\end_inset

)
\end_layout

\begin_layout Enumerate
A Servlet container (such as 
\begin_inset CommandInset href
LatexCommand href
name "Tomcat"
target "http://tomcat.apache.org/"

\end_inset

)
\end_layout

\begin_layout Subsection
Installation
\end_layout

\begin_layout Enumerate
Clone the project as explained in 
\begin_inset CommandInset href
LatexCommand href
name "https://code.google.com/p/nibirumobile/source/checkout"
target "https://code.google.com/p/nibirumobile/source/checkout"

\end_inset


\end_layout

\begin_layout Enumerate
Run 
\begin_inset Quotes eld
\end_inset

mvn eclipse:eclipse
\begin_inset Quotes erd
\end_inset

 from root directory in order to build the Eclipse project from Maven files
 and downloading target platform JARS.
 
\end_layout

\begin_layout Enumerate
Import the projects into Eclipse.
 You must create a M2_REPO classpath variable pointing to the m2/repository
 directory in your home directory.
\end_layout

\begin_layout Subsection
Sample project
\end_layout

\begin_layout Enumerate
As in the previous section, import the projects into Eclipse.
\end_layout

\begin_layout Enumerate
Android:
\end_layout

\begin_deeper
\begin_layout Enumerate
Select project properties and mark all the libraries for export (Java Build
 Path section).
\end_layout

\begin_layout Enumerate
Run the project usign the Android plugin.
\end_layout

\end_deeper
\begin_layout Enumerate
GWT:
\end_layout

\begin_deeper
\begin_layout Enumerate
Compile the project using the GWT plugin.
\end_layout

\begin_layout Enumerate
Run the project inside a Web server or inside PhoneGap.
 Running on a Web server+browser, you can test it usgin GWT's development
 mode (however, you will not have access to mobile hardware).
\end_layout

\end_deeper
\begin_layout Part
Project Structure
\end_layout

\begin_layout Section
Main subprojects
\end_layout

\begin_layout Standard
The structure for Nibiru Mobile project is arranged in an hierarchical way.
 In this structure, the main subprojects are the following:
\end_layout

\begin_layout Itemize
ar.com.oxen.nibiru.mobile.core
\end_layout

\begin_layout Itemize
ar.com.oxen.nibiru.mobile.android
\end_layout

\begin_layout Itemize
ar.com.oxen.nibiru.mobile.gwt
\end_layout

\begin_layout Itemize
ar.com.oxen.nibiru.mobile.mgwt
\end_layout

\begin_layout Itemize
ar.com.oxen.nibiru.mobile.smartgwt
\end_layout

\begin_layout Itemize
ar.com.oxen.nibiru.mobile.kendoui
\end_layout

\begin_layout Standard
They can be found on a directory called 
\begin_inset Quotes eld
\end_inset

main
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section
Sample project
\end_layout

\begin_layout Standard
A sample application can be found in the ar.com.oxen.nibiru.mobile.sample.app
 project.
 It can be found at “sample” directory, along with different platform implementa
tions.
\end_layout

\begin_layout Subsection
Typical project structure
\end_layout

\begin_layout Standard
Typically, a project will be divided into two or more modules:
\end_layout

\begin_layout Itemize
A module containing app-specific components, which are generic and re-usable.
\end_layout

\begin_layout Itemize
One or more modules containing platform-specific components.
\end_layout

\begin_layout Standard
These modules are explained in the following sections.
 For a deeper undestanding, please look at the sample application.
\end_layout

\begin_layout Subsubsection
Application module
\end_layout

\begin_layout Standard
The application module usually will depend on ar.com.oxen.nibiru.mobile.core
 module, in order to access the platform-agnostic API.
\end_layout

\begin_layout Standard
In a typical application, this module will contain:
\end_layout

\begin_layout Itemize
An ar.com.oxen.nibiru.mobile.core.api.app.EntryPoint implementation, for application
 startup logic.
\end_layout

\begin_layout Itemize
UI logic:
\end_layout

\begin_deeper
\begin_layout Itemize
All the presenters.
\end_layout

\begin_layout Itemize
A enumeration for custom places.
\end_layout

\begin_layout Itemize
A presenter mapper, for mapping places with presentes.
\end_layout

\end_deeper
\begin_layout Itemize
Text internationalization resources (properties and an interface).
\end_layout

\begin_layout Itemize
Business logic components (which may be divide into API and implementation).
\end_layout

\begin_layout Itemize
Data access API (DAOs and domain model).
\end_layout

\begin_layout Itemize
Remote services API.
\end_layout

\begin_layout Standard
Some packaging issues must be taken into account:
\end_layout

\begin_layout Itemize
In order to compile from GWT, you must include:
\end_layout

\begin_deeper
\begin_layout Itemize
A Module.gwt.xml file, with proper configuraiton for source paths.
\end_layout

\begin_layout Itemize
Java source files.
\end_layout

\end_deeper
\begin_layout Subsubsection
Platform modules
\end_layout

\begin_layout Standard
Platform specific modules will depend on application module and on Nibiru
 Mobile platform-specific module.
\end_layout

\begin_layout Standard
Such modules typically will inlcude:
\end_layout

\begin_layout Itemize
Classes for configuring dependency injection.
\end_layout

\begin_layout Itemize
View components, in order to implement presenter displays.
\end_layout

\begin_layout Itemize
Any platform-specific file or class required for proper application operation.
\end_layout

\begin_layout Paragraph
Android
\end_layout

\begin_layout Standard
Android modules will depend on application module and on ar.com.oxen.nibiru.mobile.an
droid module.
\end_layout

\begin_layout Standard
Android specific components can be set up as follows:
\end_layout

\begin_layout Itemize
In the AndroidManifest.xml file declare the ar.com.oxen.nibiru.mobile.android.app.Bootst
rapActivity as launcher.
 For each presenter, you must declare a ar.com.oxen.nibiru.mobile.android.ui.mvp.Present
erActivity.
 The action name must match {app package name}.place.{place name}.
\end_layout

\begin_layout Itemize
Dependency injection is configured using 
\begin_inset CommandInset href
LatexCommand href
name "Guice"
target "http://code.google.com/p/google-guice/"

\end_inset

, so you must just write a com.google.inject.AbstractModule subclass for each
 module.
 Since 
\begin_inset CommandInset href
LatexCommand href
name "RoboGuice"
target "http://code.google.com/p/roboguice/"

\end_inset

 is the framework which startups Guice, you must declare a string array
 resource called 
\begin_inset Quotes eld
\end_inset

roboguice_modules
\begin_inset Quotes erd
\end_inset

, which indicates what modules must be used (check the roboguice.xml file
 in the sample).
\end_layout

\begin_layout Itemize
The ar.com.oxen.nibiru.mobile.android.ui.mvp.BaseAndroidView class can be used as
 the super class for all the view implementations.
\end_layout

\begin_layout Itemize
Persistence is managed using 
\begin_inset CommandInset href
LatexCommand href
name "OrmLite"
target "http://ormlite.com/"

\end_inset

, so you must create a com.j256.ormlite.android.apptools.OrmLiteSqliteOpenHelper
 subclass for database creation, upgrade, etc.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "Jackson"
target "http://jackson.codehaus.org/"

\end_inset

 JSON serialization is configured using an org.codehaus.jackson.map.ObjectMapper
 instance.
 If you need yo customize serialization, you can write a javax.inject.Provider<Obj
ectMapper> for this class.
\end_layout

\begin_layout Paragraph
GWT
\end_layout

\begin_layout Standard
GWT modules have more options on the UI layer.
 Usually, you will choose an UI implementation for your application (however,
 since they are HTML-based, you can mix UI technologies.
\end_layout

\begin_layout Standard
The following modules are provided for different UI technologies support:
\end_layout

\begin_layout Itemize
ar.com.oxen.nibiru.mobile.gwt: For generic GWT components and cross technologies
 (such as GWT-PhoneGap, GWT-Mobile-Persistence, etc.).
\end_layout

\begin_layout Itemize
ar.com.oxen.nibiru.mobile.mgwt: 
\begin_inset CommandInset href
LatexCommand href
name "MGWT"
target "http://www.m-gwt.com/"

\end_inset

 user interface implementation.
\end_layout

\begin_layout Itemize
ar.com.oxen.nibiru.mobile.smartgwt: 
\begin_inset CommandInset href
LatexCommand href
name "SmartGWT Mobile"
target "http://www.smartclient.com/product/smartgwtMobile.jsp"

\end_inset

 user interface implementation.
\end_layout

\begin_layout Itemize
ar.com.oxen.nibiru.mobile.kendoui: 
\begin_inset CommandInset href
LatexCommand href
name "Kendo UI"
target "http://www.kendoui.com/mobile.aspx"

\end_inset

 user interface implementation.
\end_layout

\begin_layout Standard
Regarding platform-specific components, you will typically need:
\end_layout

\begin_layout Itemize
A Module.gwt.xml inhetinting the application module and the platform specific
 modules.
\end_layout

\begin_layout Itemize
A com.google.gwt.core.client.EntryPoint in order to startup the GWT application.
 This will typically just call the Nibiru Mobile bootstrap.
\end_layout

\begin_layout Itemize
Dependency injection is done through 
\begin_inset CommandInset href
LatexCommand href
name "GIN"
target "http://code.google.com/p/google-gin/"

\end_inset

.
 Because of this, you must create a ar.com.oxen.nibiru.mobile.gwt.ioc.GwtInjector
 subinterface and a com.google.gwt.inject.client.AbstractGinModule sublcass for
 each module.
\end_layout

\begin_layout Itemize
An interface extending both, application message internationalization interface
 and com.google.gwt.i18n.client.Messages.
 This way, GWT knows that it must be treated as an i18n interface.
 Also, you must declare the used languages in the Module.gwt.xml file.
\end_layout

\begin_layout Part
Modules
\end_layout

\begin_layout Section
Core
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.core project contains common classes: unified API
 and generic components.
 These classes are arranged into different packages, which are explained
 in the following sections.
\end_layout

\begin_layout Subsection
Generic cross components
\end_layout

\begin_layout Subsubsection
Application
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.core.api.app package contains interfaces related
 to app setup.
\end_layout

\begin_layout Standard
The Bootstrap interface represents the steps which are neccessary in order
 to start the application on a given platform.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/app/Bootstrap.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To put it in another way, there are specific bootstrap for Android, GWT,
 etc.
\end_layout

\begin_layout Standard
On the other side, the EntryPoint interface represents startup logic which
 is application-specific, but platform independent.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/app/EntryPoint.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Typically, there will be a unique entry point for each application.
 For example, you could have an entry point like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
 imports, etc ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class SampleEntryPoint implements EntryPoint {
\end_layout

\begin_layout Plain Layout

	private PlaceManager placeManager;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Inject
\end_layout

\begin_layout Plain Layout

	public SampleEntryPoint(PlaceManager placeManager) {
\end_layout

\begin_layout Plain Layout

		super();
\end_layout

\begin_layout Plain Layout

		this.placeManager = placeManager;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public void onApplicationStart() {
\end_layout

\begin_layout Plain Layout

		this.placeManager.createPlace(DefaultPlaces.LOGIN).go();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Asynchronous callbacks
\end_layout

\begin_layout Standard
Since the frameworks aims to be compatible with HTML5 development, it must
 take into account asynchronous callback handling.
 In other platforms (such as Android or iOS), you would simply create threads
 as needed (for example, when you are going to execute a blocking operation).
 However, GWT code is translated into JavaScript, which is single-threaded.
 When a blocking operation is excetued (such as an Ajax call or a WebSQL
 operation) is executed, a callback must be used.
\end_layout

\begin_layout Standard
So, portable code must be written using callbacks.
 In order to accomplish this, the package ar.com.oxen.nibiru.mobile.core.api.async
 provides the Callback interface, which aims to unifiy different callbacks
 used on different libraries.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/async/Callback.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.core.impl.async package provides some utility classes
 for asynchronous callback handling.
\end_layout

\begin_layout Standard
The BaseCallback is a generic base class which implements the exception
 callback method, simply showing the error to the user with an alert message.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/impl/async/BaseCallback.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On a layered application, callbacks usually will pass thorug different classes.
 However, each layer tipically would excetute some logic (otherwise, maybe
 the layer is poorly designed).
 Chaining callbacks is a tedious task, so we provide a class for this purpose.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/impl/async/ChainCallback.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It chains the exception callback method and provides a method for accessing
 the chained callback.
 For example, the following snippet shows how a login method could be implemente
d:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

private void remoteLogin(final String username,
\end_layout

\begin_layout Plain Layout

		final String password,
\end_layout

\begin_layout Plain Layout

		Callback<Boolean> callback) {
\end_layout

\begin_layout Plain Layout

	this.authenticationService.login(username,
\end_layout

\begin_layout Plain Layout

			password,
\end_layout

\begin_layout Plain Layout

			new ChainCallback<UserDto, Boolean>(callback) {
\end_layout

\begin_layout Plain Layout

		@Override
\end_layout

\begin_layout Plain Layout

		public void onSuccess(final UserDto userDto) {
\end_layout

\begin_layout Plain Layout

			if (userDto != null) {
\end_layout

\begin_layout Plain Layout

				// update profile, etc...
\end_layout

\begin_layout Plain Layout

				getChained().onSuccess(true);
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				getChained().onSuccess(false);
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Configuration
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.core.api.config package contains annotations used
 for application configuration.
 These include:
\end_layout

\begin_layout Itemize
AppName: The name of the application.
\end_layout

\begin_layout Itemize
AppVersion: The application version.
\end_layout

\begin_layout Itemize
BaseUrl: Base URL, used for remote service calling.
\end_layout

\begin_layout Standard
Such annotations are used when configuring IoC injector for a given application
 (see example code).
\end_layout

\begin_layout Subsubsection
Registration handling
\end_layout

\begin_layout Standard
Some components (usually, listeners, handlers, etc.) require some kind of
 registration.
 When a component is registered inside another, a good approach is returning
 an object used for unregistering it in a future.
 In order to unify such process, the ar.com.oxen.nibiru.mobile.core.api.handler
 provides the HandlerRegistration interface:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/handler/HandlerRegistration.java}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Inversion of control
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.core.ioc package provides default Guice-based configurat
ion modules.
 Specific (RoboGuice for Android and GIN for GWT) configuration modules
 can be found on platform-specific projects.
\end_layout

\begin_layout Subsubsection
Common classes
\end_layout

\begin_layout Standard
There are interfaces which don't fit well into any of the above categories.
 They are stored inside ar.com.oxen.nibiru.mobile.core.api.common and ar.com.oxen.nibiru.mo
bile.core.impl.common packages - until we improve the design :).
\end_layout

\begin_layout Standard
The Configurable interface represent anything that can have parameters:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/common/Configurable.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ar.com.oxen.nibiru.mobile.core.impl.common.AbstractConfigurable provides a base
 implementation for configurables.
\end_layout

\begin_layout Standard
Meanwhile, Identifiable represents anything that has an identifier:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/common/Identifiable.java}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Unified API components
\end_layout

\begin_layout Subsubsection
Event handling
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.core.api.event package provides an unified interface
 for accessing an EventBus:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/event/EventBus.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Due to platform limitations, Events are identified by its ID (instead of
 using the class, as usual).
 They are represented by this this interface:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/event/Event.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Also, an Event can have parameters (Configurable interface).
 Together with EventBus, you can fire Events using DSL-like method chaining:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

eventBus.createEvent("showAlert")
\end_layout

\begin_layout Plain Layout

		.addParameter("message", message)
\end_layout

\begin_layout Plain Layout

		.fire();  
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The EventHandler interface is also standardized:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/event/EventHandler.java}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
HTTP requests
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.core.api.http package provides interfaces for posting
 HTTP messages in an unified way.
\end_layout

\begin_layout Standard
The HttpManager allows sending this kind of messages:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/http/HttpManager.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
(currently, only POST is needed).
 It receives a HttpCallback:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/http/HttpCallback.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which mus supply methods for creating the request data and parsing the HTTP
 response.
\end_layout

\begin_layout Standard
This way, message creation is decoupled from HTTP messaging implementation.
\end_layout

\begin_layout Subsubsection
Object serialization
\end_layout

\begin_layout Standard
When sending an object across the network, some kind of serialization is
 needed.
 For example, you could convert the object into a JSON or a XML stream.
 The package ar.com.oxen.nibiru.mobile.core.api.serializer provides the Serializer
 interface, which abstracts such process:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/serializer/Serializer.java}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Remote services
\end_layout

\begin_layout Standard
Remote services are also abstracted.
 They are represented by the RemoteService interface form ar.com.oxen.nibiru.mobile.c
ore.api.service package:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/service/RemoteService.java}
\end_layout

\end_inset

Remote service implementation is responsible for building the message body.
 The ar.com.oxen.nibiru.mobile.core.impl.service includes some common implementations:
\end_layout

\begin_layout Itemize
JsonRpcService, for 
\begin_inset CommandInset href
LatexCommand href
name "JSON-RPC"
target "http://json-rpc.org/"

\end_inset

 messages.
\end_layout

\begin_layout Itemize
RestService, for REST-like messages (a simple POST using the URL for the
 method name).
\end_layout

\begin_layout Standard
Both implementations rely on HttpManager.
\end_layout

\begin_layout Subsubsection
User interface
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.core.api.ui package includes interfaces for manipulating
 user interface.
 At this level, just an AlertManager is provided:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/ui/AlertManager.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It allows showing messages to the user.
\end_layout

\begin_layout Standard
The remaining functionality is included in different subpackages.
\end_layout

\begin_layout Paragraph
Place management
\end_layout

\begin_layout Standard
Navigation between views is represented through places.
 The ar.com.oxen.nibiru.mobile.core.api.ui.place package provides interfaces useful
 for accomplishing this task.
\end_layout

\begin_layout Standard
The Place interface abstracts this concept:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/ui/place/Place.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Places are created using a PlaceManager instance:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/ui/place/PlaceManager.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Together, they allows navigating using a DSL-like syntax, using method chaining.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

placeManager.createPlace(DefaultPlaces.HOME)
\end_layout

\begin_layout Plain Layout

			.addParameter("message", message)
\end_layout

\begin_layout Plain Layout

			.go(false);  
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As seen on the example, there is an enumeration with identifiers for common
 places:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/ui/place/DefaultPlaces.java}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Model-View-Presenter pattern
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.core.api.ui.mvp package provides interfaces for abstractin
g different implementations for 
\begin_inset CommandInset href
LatexCommand href
name "MVP"
target "http://martinfowler.com/eaaDev/PassiveScreen.html"

\end_inset

 pattern.
\end_layout

\begin_layout Standard
Under this pattern, the UI logic is contained into a Presenter:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/ui/mvp/Presenter.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which holds a reference to a View:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/ui/mvp/View.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The view shouldn't contain logic.
 Its responsibilities should be limited to showing data (including international
ization) and firing events.
 This way, views can be easily replaced when changing the platform.
 And presenter keeps unchanged.
 This approach also allows taking advantage of native view capabilities.
\end_layout

\begin_layout Standard
When navigating to a specific place, a presenter for handling such place
 must be selected.
 This is accomplished by implementing a PresenterMapper:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/ui/mvp/PresenterMapper.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The package also provides abstractions for accessing widget data.
 The TakesValue interface allows accessing data from a widget (which must
 be adapted according the UI framework):
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/ui/mvp/TakesValue.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While the HasChangeHandler represents a widget which can fire value change
 events.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/ui/mvp/HasChangeHandler.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since many widgets can do both things (holding a value and firing change
 events), the HasValue interface combines both:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/ui/mvp/HasValue.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In a similar way, widget having click event (such as buttons) are abstracted
 by HasClickHandler interface:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/ui/mvp/HasClickHandler.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.core.impl.mvp package provides base implementations
 for both, PresenterMapper and Presenter.
\end_layout

\begin_layout Standard
The BasePresenterMapper includes an inner class, Cbk, which allows an easy
 creation of callbacks.
 It injects the AlertManager automatically into the callback.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/impl/mvp/BasePresenter.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inside a presenter which extends BasePresenter, you can simply could run
 something like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

geolocationManager.watchPosition(new Cbk<Position>() {
\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public void onSuccess(Position result) {
\end_layout

\begin_layout Plain Layout

		//...
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
User preferences
\end_layout

\begin_layout Standard
A simple API for storing user preferences can be found at ar.com.oxen.nibiru.mobile.c
ore.api.preferences package.
\end_layout

\begin_layout Standard
The Preferences interface allows accessing the preferences.
 It extends Configurable, so preference data can be loaded or stored using
 its methods.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/preferences/Preferences.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.core.impl.preferences package provides a base class
 for implementing preferences (AbstractPreferences) which provides useful
 functionality such as data conversion.
\end_layout

\begin_layout Subsubsection
Geolocation
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.core.api.geolocation provides accessing to location
 hardware.
 The main interface is GeolocationManager:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/geolocation/GeolocationManager.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Location information is accessed using Position and Coordinates interfaces:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/geolocation/Position.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/geolocation/Coordinates.java}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Generic functionality components
\end_layout

\begin_layout Subsubsection
Security
\end_layout

\begin_layout Standard
The security module provides authentication and profile access functionality.
 In a future it should include authorization too.
\end_layout

\begin_layout Standard
Security components operate at many layers.
 They are explained in the following sections.
\end_layout

\begin_layout Paragraph
User Interface
\end_layout

\begin_layout Standard
The package ar.com.oxen.nibiru.mobile.core.impl.ui.security provides a presenter
 for performing login:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/impl/ui/security/LoginPresenter.java}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Business Logic
\end_layout

\begin_layout Standard
This is the core of security functionality.
 Its API can be found at ar.com.oxen.nibiru.mobile.core.api.business.security package.
\end_layout

\begin_layout Standard
The AuthenticationManager interface alloes authenticating an user:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/business/security/AuthenticationManager.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once the user is logged in, its information can be accessed through the
 Profile interface:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/business/security/Profile.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Just inject a Profile into your component.
\end_layout

\begin_layout Standard
Finally, the HashManager enables hashing sensitive data, such as passwords.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/business/security/HashManager.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.core.impl.business.security package provides generic
 implementations of these interfaces.
\end_layout

\begin_layout Paragraph
Persistence
\end_layout

\begin_layout Standard
In order to authenticate the user when the device is offline, it is required
 to store authentication data locally.
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.core.api.data.security package provides an API for
 storing security data.
\end_layout

\begin_layout Standard
The UserDao allows loading and storing user data using the 
\begin_inset CommandInset href
LatexCommand href
name "DAO"
target "http://es.wikipedia.org/wiki/Data_Access_Object"

\end_inset

 pattern:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/data/security/UserDao.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The user information is provided by the User interface:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/data/security/User.java}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Remote Services
\end_layout

\begin_layout Standard
When possible, the device would perform the authentication against a remote
 service (on line).
 The ar.com.oxen.nibiru.mobile.core.api.service.security package provides such functiona
lity.
\end_layout

\begin_layout Standard
Such remote authentication is done using the AuthenticationService
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/service/security/AuthenticationService.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It transfers information, as usual, using 
\begin_inset CommandInset href
LatexCommand href
name "DTOs"
target "http://en.wikipedia.org/wiki/Data_transfer_object"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/service/security/LoginDto.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.core/src/main/java/ar/com/oxen/nibiru/mobi
le/core/api/service/security/UserDto.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.core.impl.service.security package provides a generic
 implementation for AuthenticationService and an annotation for configuring
 which remote service is the one used for authentication.
\end_layout

\begin_layout Section
Android
\end_layout

\begin_layout Subsection
Generic cross components
\end_layout

\begin_layout Subsubsection
Application
\end_layout

\begin_layout Standard
No platform-specific bootstrap is required, so the only action made by ar.com.oxen.
nibiru.mobile.android.app.AndroidBootstrap is calling the application entry
 point.
\end_layout

\begin_layout Standard
Application startup is performed by ar.com.oxen.nibiru.mobile.android.app.BootstrapActi
vity.
 You must configure this activity in the AndroidManifest.xml file as launcher
 activity.
\end_layout

\begin_layout Subsubsection
Inversion of control
\end_layout

\begin_layout Standard
Dependency injection is based on 
\begin_inset CommandInset href
LatexCommand href
name "RoboGuice"
target "http://code.google.com/p/roboguice/"

\end_inset

.
 It is based on 
\begin_inset CommandInset href
LatexCommand href
name "Guice"
target "http://code.google.com/p/google-guice/"

\end_inset

 and uses Guice standard modules for configuration.
\end_layout

\begin_layout Standard
This framework requires creating a string array resource in order to define
 the modules to be used.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<resources>
\end_layout

\begin_layout Plain Layout

	<string-array name="roboguice_modules">
\end_layout

\begin_layout Plain Layout

		<item>ar.com.oxen.nibiru.mobile.android.ioc.DefaultAndroidModule</item>
\end_layout

\begin_layout Plain Layout

		<item>ar.com.oxen.nibiru.mobile.android.ioc.DefaultAndroidHardwareModule</item>
\end_layout

\begin_layout Plain Layout

		<item>ar.com.oxen.nibiru.mobile.core.ioc.DefaultSecurityModule</item>
\end_layout

\begin_layout Plain Layout

		<item>ar.com.oxen.nibiru.mobile.android.ioc.DefaultSecurityModule</item>
\end_layout

\begin_layout Plain Layout

		<item>ar.com.oxen.nibiru.mobile.sample.android.Module</item>
\end_layout

\begin_layout Plain Layout

	</string-array>
\end_layout

\begin_layout Plain Layout

</resources>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An advantage of this approach is that such module list can be customized
 using Android resource selection mechanisms.
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.android.ioc package contains many Guice modules
 for default configurations.
 It also contains generic providers.
\end_layout

\begin_layout Subsection
Unified API components
\end_layout

\begin_layout Subsubsection
Event handling
\end_layout

\begin_layout Standard
Event bus listening is implemented using android.content.BroadcastReceiver
 .
 Events are thrown using android.content.Intent instances.
 The ar.com.oxen.nibiru.mobile.android.event package contains such implementations.
\end_layout

\begin_layout Subsubsection
HTTP requests
\end_layout

\begin_layout Standard
HTTP requests are implemented using 
\begin_inset CommandInset href
LatexCommand href
name "Apache HTTP Components"
target "http://hc.apache.org/"

\end_inset

, which are included in Android platform.
 Such implementation can be found on ar.com.oxen.nibiru.mobile.android.http package.
\end_layout

\begin_layout Subsubsection
Object serialization
\end_layout

\begin_layout Standard
JSON serialization is provided using 
\begin_inset CommandInset href
LatexCommand href
name "Jackson"
target "http://jackson.codehaus.org/"

\end_inset

 processor.
 The ar.com.oxen.nibiru.mobile.android.serializer package contains this implementation.
 JSON serialization is configured using an org.codehaus.jackson.map.ObjectMapper
 instance.
 If you need yo customize serialization, you can write a javax.inject.Provider<Obj
ectMapper> for this class.
\end_layout

\begin_layout Subsubsection
User interface
\end_layout

\begin_layout Standard
User interface is divided into many packages, just like at the core module.
 The ar.com.oxen.nibiru.mobile.android.ui contains a android.widget.Toast based
 implementation for ar.com.oxen.nibiru.mobile.core.api.ui.AlertManager.
\end_layout

\begin_layout Paragraph
i18n
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.android.ui.i18n contains classes used for internationaliz
ation.
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.android.ui.i18n.MessageInvocationHandler class is
 used, in conjuntion with a Java proxy, in order to read messages from a
 resource bundle according to method name.
 This way, interfaces for i18n messages can be used on both, GWT and Android.
 This approach unifies both models.
\end_layout

\begin_layout Paragraph
Place management
\end_layout

\begin_layout Standard
Places are handled using android.content.Intent instances.
 Inside the ar.com.oxen.nibiru.mobile.android.ui.place package, the IntentPlace
 wraps an intent inside a Nibiru Mobile place, while the IntentPlaceManager
 implements a place manager which IntentPlace instances.
\end_layout

\begin_layout Standard
IntentPlace just fires an intent.
 The intent action is build by convention.
 Its structure is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{application_package_name}.place.{place_name}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You must follow such convention when configurin AndroidManifest.xml file.
\end_layout

\begin_layout Paragraph
Model-View-Presenter pattern
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.android.ui.mvp contains different classes for implementin
g the MVP pattern.
 Most of them are just adapters.
 We will overlook them in order to focus on more important classes.
\end_layout

\begin_layout Standard
The main class is PresenterActivity:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.android/src/main/java/ar/com/oxen/nibiru/m
obile/android/ui/mvp/PresenterActivity.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which delegates on the presenter.
 In order to get the presenter responsible for executing the logic, it asks
 to the presenter mapper using the place as parameter.
 This class also shows the view.
\end_layout

\begin_layout Standard
For each presenter, you must add an activity of this type, following the
 conventions explained in the previous section.
\end_layout

\begin_layout Standard
Regarding the view, there is a more specific interface (AndroidView), which
 allows handling Android events:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.android/src/main/java/ar/com/oxen/nibiru/m
obile/android/ui/mvp/AndroidView.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
BaseAndroidView provides an empty implementation for this interface:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.android/src/main/java/ar/com/oxen/nibiru/m
obile/android/ui/mvp/BaseAndroidView.java}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
User preferences
\end_layout

\begin_layout Standard
User preferences are stored using android.content.SharedPreferences.
 The implementation can be found at the ar.com.oxen.nibiru.mobile.android.preferences
 package.
\end_layout

\begin_layout Subsubsection
Geolocation
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.android.geolocation package contains a native location
 service implementation.
\end_layout

\begin_layout Section
GWT
\end_layout

\begin_layout Subsection
Generic cross components
\end_layout

\begin_layout Subsubsection
Application
\end_layout

\begin_layout Standard
Due to different options (frameworks, deployment environments, etc.), application
 setup is a little more complicated on GWT.
\end_layout

\begin_layout Standard
For example, some frameworks, such as MGWT, are based on 
\begin_inset CommandInset href
LatexCommand href
name "GWT activities and places"
target "https://developers.google.com/web-toolkit/doc/latest/DevGuideMvpActivitiesAndPlaces"

\end_inset

.
 So, you may choose between using raw GWT activities and places or building
 you UI using MGWT.
 The only difference is how the root application widget is created.
 In order to abstract this, Nibiru Mobile provides the AppWidgetBootstrap
 interface:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.gwt/src/main/java/ar/com/oxen/nibiru/mobil
e/gwt/app/AppWidgetBootstrap.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The GwtPlacesBootstrap class receives an AppWidgetBootstrap and performs
 GWT places configuration.
 GwtAppWidgetBootstrap provides an AppWidgetBootstrap implementation that
 uses standard GWT widgets.
 On the ar.com.oxen.nibiru.mobile.mgwt module, the ar.com.oxen.nibiru.mobile.mgwt.app.MgwtAp
pWidgetBootstrap class provides a 
\begin_inset CommandInset href
LatexCommand href
name "MGWT"
target "http://www.m-gwt.com/"

\end_inset

-based widget for place navigation.
\end_layout

\begin_layout Standard
The GwtPlacesBootstrap also receives a DatabaseBootstrap instance:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.gwt/src/main/java/ar/com/oxen/nibiru/mobil
e/gwt/app/DatabaseBootstrap.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which creates the Web SQL database.
 However, your applicacion may not need/support a local database.
 Because of this, there is a dummy implementation, explained in the next
 section.
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "SmartGWT mobile"
target "http://www.smartclient.com/product/smartgwtMobile.jsp"

\end_inset

has a different approach.
 It is not based on GWT activities and places, so it has its own bootstrap:
 ar.com.oxen.nibiru.mobile.smartgwt.app.SmartGwtBootstrap.
 However, it still receives a DatabaseBootstrap in order to initialize the
 database.
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Kendo UI"
target "http://www.kendoui.com/mobile.aspx"

\end_inset

performs navigation between views defined in the same HTML page (you can
 navigate to external pages, but not to dynamically generated views on the
 same page).
 The Kendo UI module (still experimental) provides bootstrap classes which
 creates all the views on the startup and adds them to the host page.
 They are placed on ar.com.oxen.nibiru.mobile.kendoui.app package.
\end_layout

\begin_layout Subsubsection
Data access
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.gwt.data package contains components for accessing
 Web SQL database.
 The technologies used for this purpose are 
\begin_inset CommandInset href
LatexCommand href
name "GwtMobile-Persistence"
target "https://github.com/dennisjzh/GwtMobile-Persistence"

\end_inset

 and 
\begin_inset CommandInset href
LatexCommand href
name "persistence.js"
target "https://github.com/zefhemel/persistencejs"

\end_inset

.
 The GwtMobileDatabaseBootstrap sets up a database using these technologies.
\end_layout

\begin_layout Standard
As explained in the previous section, if you aren't going to support Web
 SQL database (for example if you are targetting browsers that doesn't support
 this feature), you can use DummyDatabaseBootstrap.
\end_layout

\begin_layout Subsubsection
Registration handling
\end_layout

\begin_layout Standard
Since GWT API provides a com.google.web.bindery.event.shared.HandlerRegistration
 class for un-registering handlers, the framework provides a ar.com.oxen.nibiru.mobi
le.gwt.handler.HandlerRegistrationAdapter which adapts to the Nibiru Mobile
 API.
\end_layout

\begin_layout Subsubsection
Inversion of control
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.gwt.ioc contains many GIN modules useful for default
 configurations.
 Also, it provides a base interface for creating injectors based on GIN
 (GwtInjector).
\end_layout

\begin_layout Standard
On ar.com.oxen.nibiru.mobile.mgwt module, the ar.com.oxen.nibiru.mobile.mgwt.ioc package
 provides GIN modules for configuring dependency injection with MGWT.
 Similary, the ar.com.oxen.nibiru.mobile.smartgwt module contains such modules
 in the ar.com.oxen.nibiru.mobile.smartgwt.ioc package.
 The same applies for ar.com.oxen.nibiru.mobile.kendoui with the ar.com.oxen.nibiru.mobil
e.kendoui.ioc package.
\end_layout

\begin_layout Subsection
Unified API components
\end_layout

\begin_layout Subsubsection
Event handling
\end_layout

\begin_layout Standard
GWT event handling is implemented using a wrapper for com.google.web.bindery.event.sh
ared.EventBus.
 This adapter and simple event/event handler implementations can be found
 at the ar.com.oxen.nibiru.mobile.gwt.event package.
\end_layout

\begin_layout Subsubsection
HTTP requests
\end_layout

\begin_layout Standard
The com.google.gwt.http.client.RequestBuilder class is used in order to perform
 HTTP request.
 The adapter to Nibiru Mobile API is located at the ar.com.oxen.nibiru.mobile.gwt.http
 package.
 Its name is RequestBuilderHttpManager.
\end_layout

\begin_layout Subsubsection
Object serialization
\end_layout

\begin_layout Standard
The package ar.com.oxen.nibiru.mobile.gwt.serializer contains GWT implementation
 for JSON serialization: AutoBeanSerializer.
 It is based in 
\begin_inset CommandInset href
LatexCommand href
name "AutoBeans"
target "http://code.google.com/p/google-web-toolkit/wiki/AutoBean"

\end_inset

 technology, included in GWT.
\end_layout

\begin_layout Subsubsection
User interface
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.gwt.ui package contains an alert manager implementation
 (GwtAlertManager) which uses Window.alert() in order to show messages.
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.mgwt.ui from ar.com.oxen.nibiru.mobile.mgwt module provides
 a similar implementation, but using MGWT com.googlecode.mgwt.ui.client.dialog.Dialogs.
\end_layout

\begin_layout Standard
SmartGWT mobile has a non-working implementation, so it currently uses Window.ale
rt().
 It can be found at ar.com.oxen.nibiru.mobile.smartgwt.ui.mvp package.
\end_layout

\begin_layout Paragraph
Place management
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.gwt.ui.place package contains classes that adapt
 
\begin_inset CommandInset href
LatexCommand href
name "GWT's activities and places"
target "https://developers.google.com/web-toolkit/doc/latest/DevGuideMvpActivitiesAndPlaces"

\end_inset

 to Nibiru Mobile place management API.
 GwtPlaceManager is a place manager implementation that delegates on com.google.gw
t.place.shared.PlaceController for navigation.
 It creates SimplePlace instances, which just wraps a GWT place.
\end_layout

\begin_layout Standard
DefaultActivityMapper and DefaultPlaceHistoryMapper provide generic implementati
ons for both, ActivityMapper and PlaceHistoryMapper.
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.mgwt module provides the ar.com.oxen.nibiru.mobile.mgwt.ui.pla
ce.DefaultAnimationMapper, which just selects a random animation for place
 transition.
\end_layout

\begin_layout Standard
On the other hand, SmartGWT Mobile doesn't use activities and places.
 The ar.com.oxen.nibiru.mobile.smartgwt.ui.place package provides com.smartgwt.mobile.clie
nt.widgets.layout.NavStack based navigation implementations (place and place
 manager).
\end_layout

\begin_layout Standard
Kendo UI support for place management can be found at ar.com.oxen.nibiru.mobile.kendo
ui.ui.place package.
\end_layout

\begin_layout Paragraph
Model-View-Presenter pattern
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.gwt.ui.mvp package contains classes (API implementations
 and adapteres) for implementing the MVP pattern.
\end_layout

\begin_layout Standard
The main class is PresenterActivity:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.gwt/src/main/java/ar/com/oxen/nibiru/mobil
e/gwt/ui/mvp/PresenterActivity.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which delegates on the presenter.
 This activity receives the presenter responsible for executing the logic
 and the place from DefaultActivityMapper.
 This class also sets the display widget.
\end_layout

\begin_layout Standard
Regarding the view, a base class is provided:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../ar.com.oxen.nibiru.mobile.gwt/src/main/java/ar/com/oxen/nibiru/mobil
e/gwt/ui/mvp/BaseGwtView.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On the ar.com.oxen.nibiru.mobile.mgwt module, you can find MGWT adapters and
 base classes for MVP pattern inside the ar.com.oxen.nibiru.mobile.mgwt.ui.mvp
 package.
 In a similar way, the ar.com.oxen.nibiru.mobile.smartgwt.ui.mvp package from ar.com.oxen.
nibiru.mobile.smartgwt module provides SmartGWT Mobile implementations for
 the same pattern.
\end_layout

\begin_layout Standard
Kendo UI support for MVP pattern can be found at ar.com.oxen.nibiru.mobile.kendoui.ui.m
vp package.
\end_layout

\begin_layout Subsubsection
User preferences
\end_layout

\begin_layout Standard
The ar.com.oxen.nibiru.mobile.gwt.preferences package contains a cookie-based
 preferences services (CookiesPreferences).
 In a future, a Web SQL preferences could be implemented.
\end_layout

\begin_layout Subsubsection
Geolocation
\end_layout

\begin_layout Standard
Geolocation (as hardware access in general) is implemented using 
\begin_inset CommandInset href
LatexCommand href
name "Apache Cordova"
target "http://incubator.apache.org/cordova/"

\end_inset

 (aka 
\begin_inset CommandInset href
LatexCommand href
name "PhoneGap"
target "http://phonegap.com/"

\end_inset

).
 Since this API is JavaScript-based, 
\begin_inset CommandInset href
LatexCommand href
name "GWT-PhoneGap"
target "http://code.google.com/p/gwt-phonegap/"

\end_inset

 is used in order to access it from GWT.
\end_layout

\begin_layout Standard
Geolocation implementations are found in the ar.com.oxen.nibiru.mobile.gwt.geolocation
 package.
\end_layout

\begin_layout Part
Deployment
\end_layout

\begin_layout Section
HTML
\end_layout

\begin_layout Subsection
Standard Web server
\end_layout

\begin_layout Standard
If you aren't targetting mobile development (event when Nibiru Mobile has
 
\begin_inset Quotes eld
\end_inset

mobile
\begin_inset Quotes erd
\end_inset

 in its name!), you can deploy it on an standard web server and run the
 app from a desktop browser.
\end_layout

\begin_layout Standard
Just compile and deploy it as you would do with any GWT application.We recommend
 you reading the 
\begin_inset CommandInset href
LatexCommand href
name "GWT documentation"
target "https://developers.google.com/web-toolkit/doc/latest/DevGuideDeploying"

\end_inset

 regarding this aspect.
\end_layout

\begin_layout Standard
If you are targetting mobile development, you can even use a Web server
 + desktop browser in order to test quickly your application.
 You can even use GWT development mode in order to avoid full compilation
 when developing the application.
 Again, we recommend you reading 
\begin_inset CommandInset href
LatexCommand href
name "GWT documentation"
target "https://developers.google.com/web-toolkit/doc/latest/DevGuideCompilingAndDebugging"

\end_inset

 related to this point.
 However, you can't test hardware-related fucntionality under a desktop
 browser (maybe geolocation is the exception, which is supported by some
 browsers).
\end_layout

\begin_layout Subsection
Apache Cordova
\end_layout

\begin_layout Standard
In order to deploy to a mobile device (or a simulator), you must follow
 
\begin_inset CommandInset href
LatexCommand href
name "PhoneGap instructions"
target "http://docs.phonegap.com/en/2.2.0/guide_getting-started_index.md.html"

\end_inset

 for your platform.
 Typically, you will need creating a project for each platform and copying
 the GWT generated files inside each one.
\end_layout

\begin_layout Subsection
Kendo UI considerations
\end_layout

\begin_layout Standard
Kendo UI Mobile has a commercial license.
 There is not OpenSource license.
 So, it can be included in Nibiru Mobile.
 When deploying an application built with this framework, you must include
 your Kendo UI Mobile licensed copy inside a web app directory and load
 them from HTML host page.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

	<head>
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

		<script src="nibiru_mobile_sample/js/jquery.min.js"></script>
\end_layout

\begin_layout Plain Layout

		<script src="nibiru_mobile_sample/js/kendo.mobile.min.js"></script>
\end_layout

\begin_layout Plain Layout

		<link href="nibiru_mobile_sample/styles/kendo.common.min.css" rel="stylesheet"
 />
\end_layout

\begin_layout Plain Layout

		<link href="nibiru_mobile_sample/styles/kendo.mobile.all.min.css" rel="stylesheet"
 />
\end_layout

\begin_layout Plain Layout

		<script type="text/javascript" src="nibiru_mobile_sample/nibiru_mobile_sample.n
ocache.js"></script>
\end_layout

\begin_layout Plain Layout

	</head>
\end_layout

\begin_layout Plain Layout

	<body>
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

	</body>
\end_layout

\begin_layout Plain Layout

</html> 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can copy the files to the webapp manually or include them into a custom-made
 GWT module (inside a 
\begin_inset Quotes eld
\end_inset

public
\begin_inset Quotes erd
\end_inset

 directory).
 Using the second option, when including such module, the files will be
 copied automatically.
\end_layout

\begin_layout Section
Android
\end_layout

\begin_layout Standard
Deploying as native Android application is quite simple.
 You must just create an Android application linked with Nibiru Mobile dependenc
ies.
 You can even configure Maven in order to creating the Eclipse project configura
tion for Android (such as it is done on the example project).
\end_layout

\begin_layout Standard
The only issue is that Android Eclipse plugin requires linked libraries
 to be exported (otherwise, they aren't included when generating APK).
 In order to fix this, select the project -> Properties -> Java Build Path
 -> Order and Export and check all the dependencies.
\end_layout

\begin_layout Part
License
\end_layout

\begin_layout Standard
The framework is distributed under 
\begin_inset CommandInset href
LatexCommand href
name "Apache 2.0"
target "http://www.apache.org/licenses/LICENSE-2.0.html"

\end_inset

 license.
\end_layout

\end_body
\end_document
